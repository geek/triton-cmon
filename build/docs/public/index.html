<!DOCTYPE html>
<html lang="en">
<head>
    <title>Joyent Engineering Guide</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" type="text/css" href="media/css/restdown.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
</head>
<body>
<div id="header">
    <h1>Joyent Engineering Guide Documentation</h1>
</div>

    <div id="sidebar">
<ul>
  <li><div><a href="#repository-guidelines">Repository Guidelines</a></div>
  <ul>
    <li><div><a href="#rule-1-fcs-quality-all-the-time">Rule #1: FCS Quality All the Time</a></div></li>
    <li><div><a href="#repositories-and-documentation">Repositories and documentation</a></div></li>
    <li><div><a href="#repository-naming">Repository Naming</a></div></li>
    <li><div><a href="#language">Language</a></div></li>
    <li><div><a href="#code-layout">Code Layout</a></div></li>
    <li><div><a href="#coding-style">Coding Style</a></div></li>
    <li><div><a href="#lint">Lint</a></div></li>
    <li><div><a href="#copyright">Copyright</a></div></li>
    <li><div><a href="#testing">Testing</a></div></li>
    <li><div><a href="#cscope">cscope</a></div></li>
    <li><div><a href="#documentation">Documentation</a></div></li>
    <li><div><a href="#node-build">Node Build</a></div></li>
    <li><div><a href="#managing-node-dependencies">Managing Node Dependencies</a></div></li>
    <li><div><a href="#node-add-ons-binary-modules">Node add-ons (binary modules)</a></div></li>
    <li><div><a href="#commit-comments-and-jira-tickets">Commit Comments and JIRA Tickets</a></div></li>
  </ul></li>
  <li><div><a href="#logging">Logging</a></div></li>
  <li><div><a href="#smf-integration">SMF Integration</a></div>
  <ul>
    <li><div><a href="#managing-processes-under-smf">Managing processes under SMF</a></div></li>
    <li><div><a href="#service-logs">Service logs</a></div></li>
  </ul></li>
  <li><div><a href="#rest-api-guidelines">REST API Guidelines</a></div>
  <ul>
    <li><div><a href="#request-identifiers">Request Identifiers</a></div></li>
    <li><div><a href="#naming-endpoints">Naming Endpoints</a></div></li>
    <li><div><a href="#error-handling">Error Handling</a></div></li>
  </ul></li>
  <li><div><a href="#bash-programming-guidelines">Bash programming guidelines</a></div>
  <ul>
    <li><div><a href="#xtrace">xtrace</a></div></li>
    <li><div><a href="#error-handling-2">Error handling</a></div></li>
    <li><div><a href="#running-subcommands">Running subcommands</a></div></li>
    <li><div><a href="#automatic-checks">Automatic Checks</a></div></li>
    <li><div><a href="#temporary-files">Temporary Files</a></div></li>
    <li><div><a href="#parsing-command-line-options">Parsing command line options</a></div></li>
    <li><div><a href="#command-line-scripts-that-perform-multiple-complex-tasks">Command-line scripts that perform multiple complex tasks</a></div></li>
  </ul></li>
  <li><div><a href="#jira-best-practices-for-customer-issues">JIRA best practices for Customer Issues</a></div>
  <ul>
    <li><div><a href="#jira-updates">JIRA Updates</a></div></li>
    <li><div><a href="#resolving-jira-tickets">Resolving JIRA Tickets</a></div></li>
  </ul></li>
  <li><div><a href="#writing-makefiles">Writing Makefiles</a></div></li>
  <li><div><a href="#software-development-process">Software development process</a></div></li>
  <li><div><a href="#security-statement-and-best-practices">Security Statement and Best Practices</a></div>
  <ul>
    <li><div><a href="#production-code-deployment-process">Production code deployment process</a></div></li>
  </ul></li>
  <li><div><a href="#miscellaneous-best-practices">Miscellaneous Best Practices</a></div></li>
  <li><div><a href="#examples">Examples</a></div></li>
</ul>

    </div>
    <div id="content">

<!--
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.
-->

<!--
    Copyright (c) 2014, Joyent, Inc.
-->


<h1>Joyent Engineering Guide</h1>
<div class="intro">


<p>This document describes standards and best practices for software development at
Joyent. These standards are intended to maintain product quality and to provide
consistency across codebases to make it easier for all engineers to learn new
parts of the system. This latter goal is important to encourage everyone to feel
comfortable diving into all parts of the system, as is often necessary when
debugging.</p>

<p>It's important to remember that all situations are unique, so rules should not
be followed blindly. However, these guidelines represent the best practices
agreed upon by the team. If you feel it necessary to diverge from them, that's
okay, but be prepared to explain why.</p>

<p>Note: In this document (and elsewhere at Joyent), a service implementing an API
is referred to by the API name itself. For example, "SAPI" denotes both the
"Services API" in the abstract as well as the software component that implements
that API.</p>


</div>
<h1 id="repository-guidelines">Repository Guidelines</h1>

<p>These guidelines cover naming, structure, and processes around repositories.
A template repository is included in this repo so you can quickly get something
working that follows these guidelines.</p>

<h2 id="rule-1-fcs-quality-all-the-time">Rule #1: FCS Quality All the Time</h2>

<p>In general, use the "master" branch for development. Development should not be
ongoing in the release branches. "master" must be
<strong>FCS quality all the times</strong>. The deliverables should always be of
high enough quality to ship to a first customer, FCS (first customer ship).</p>

<p>When working on large features, it's tempting to use development branches that
eventually get integrated into master. Indeed, this is sometimes necessary.
However, it should be avoided when possible, as it means people are running dev
branches rather than "master", which can lead to a <a href="http://wiki.illumos.org/display/illumos/On+the+Quality+Death+Spiral">quality death spiral
(QDS)</a>
as fewer people actually run the mainline tree. Where possible, consider
whether larger projects can be split into reasonably-sized chunks that can
individually be integrated into "master" without breaking existing
functionality. This allows you to continue developing on "master" while still
being able to commit frequently.</p>

<h2 id="repositories-and-documentation">Repositories and documentation</h2>

<p>Open-source projects and components live at github.com/joyent. These include
Node.js, SmartOS, Triton, Manta, and a large number of smaller Node modules and
other components. Some components still live under individuals' github
accounts, but new components should generally be created under the "joyent"
organization.</p>

<p>Note that just because a repo is on github doesn't mean its issues are tracked
there. That's decided on a per-project basis.</p>

<p>Some older components (and a few proprietary ones that are still used) are
managed by gitosis running on the internal Joyent git server. Files, commits,
and documentation for these projects can be browsed at mo.joyent.com by Joyent
employees.</p>

<h2 id="repository-naming">Repository Naming</h2>

<p>For repositories representing an API, the repo name that matches how the API is
discussed (spoken, chatted and emailed) means you'll get the repo name right on
first guess. If you can get away with it, a repo named after the abbreviate API
name is best. For example:</p>

<pre><code>Network API -&gt; NAPI -&gt; napi.git          # Good.
                    -&gt; network-api.git   # Less good.
                    -&gt; network_api.git   # Even less good.
                    -&gt; NAPI.git          # Whoa! Capital letters are crazy here.
</code></pre>

<h2 id="language">Language</h2>

<p>New server-side projects should almost certainly use Node.js with C/C++
components as needed. Consolidating onto one language makes it easier for
everyone to dig into other teams' projects as needed (for development as well
as debugging) and allows us to share code and tools.</p>

<h2 id="code-layout">Code Layout</h2>

<p>Here is a suggested directory/file structure for your repository. All
repos <strong>must</strong> have a <code>README.md</code> and <code>Makefile</code>. The others are suggested
namings for particular usages, should your repo require them.</p>

<pre><code>build/          Built bits.
deps/           Git submodules and/or commited 3rd-party deps should go
                here. See "node_modules/" for node.js deps.
docs/           Project docs. Uses markdown and man.
lib/            JavaScript source files.
node_modules/   Node.js deps, either populated at build time or commited.
                See Managing Node Dependencies.
pkg/            Package lifecycle scripts
smf/manifests   SMF manifests
smf/methods     SMF method scripts
src/            C/C++ source files.
test/           Test suite (able to generate TAP output).
tools/          Miscellaneous dev/upgrade/deployment tools and data.
Makefile        See below.
package.json    npm module info, if applicable (holds the project version)
README.md       See below.
</code></pre>

<p>"docs" or "doc"? "test" or "tst"? We're not being religious about the
directory names, however the Makefile target names should use the names
specified below to allow automated build tools to rely on those names. The
reason to suggest "docs" and "test" as the directory names is to have the
same name as the Makefile targets.</p>

<h3 id="readmemd">README.md</h3>

<p>Every repository <strong>must</strong> have in its root a README.md (Markdown) file that
describes the repo and covers:</p>

<ul>
<li>the name of the API or other component(s) contained in the repo and a brief
description of what they do</li>
<li>the boilerplate text for referencing the contribution and issue tracking
guidelines of the master project (Triton or Manta)</li>
<li>the JIRA project for this repo (and any additional instructions, like how JIRA
components are used for this project)</li>
<li>owners of the project</li>
<li>the style and lint configurations used, any additional pre-commit checks, and
any non-standard useful Makefile targets</li>
<li>some overview of the structure of the project, potentially including
descriptions of the subcomponents, directory structure, and basic design
principles</li>
<li>basic development workflow: how to run the code and start playing with it</li>
</ul>

<p>It's strongly recommended to start with the template in this repo.</p>

<h3 id="makefile">Makefile</h3>

<p>All repos <strong>must</strong> have a Makefile that defines at least the following targets:</p>

<ul>
<li><code>all</code>: builds all intermediate objects (e.g., binaries, executables, docs,
etc.). This should be the default target.</li>
<li><code>check</code>: checks all files for adherence to lint, style, and other
repo-specific rules not described here.</li>
<li><code>clean</code>: removes all built files</li>
<li><code>prepush</code>: runs all checks/tests required before pushing changes to the repo</li>
<li><code>docs</code>: builds documentation (restdown markdown, man pages)</li>
<li><code>test</code>: Runs the test suite. Specifically, this runs the subset of the
tests that are runnable in a dev environment. See the "Testing" section
below.</li>
<li><code>release</code>: build releasable artifacts, e.g. a tarball (for projects that
generate release packages)</li>
</ul>

<p>The <code>check</code> and <code>test</code> targets <strong>must</strong> fail if they find any 'check'
violations or failed tests. The <code>prepush</code> target is intended to cover all
pre-commit checks. It <strong>must</strong> run successfully before any push to the repo.
It <strong>must</strong> also be part of the automated build. Any commit which introduces a
prepush failure <strong>must</strong> be fixed immediately or backed out. A typical prepush
target will look like the following, but some non-code repositories might
differ (e.g. not have a test suite):</p>

<pre><code>prepush: check test
        @echo "Okay to push."
</code></pre>

<p>There are several modular Makefiles you can use to implement most of this. See
"Writing Makefiles" (below) for details.</p>

<h2 id="coding-style">Coding Style</h2>

<p>Every repository <strong>must</strong> have a consistent coding style that is enforced by
some tool. It's not necessary that all projects use the same style, though it's
strongly suggested to keep differences to a minimum (e.g., only hard vs. soft
tabs and tabstops). All styles <strong>must</strong> limit line length to 80 columns.
Existing style-checking tools include:</p>

<ul>
<li>C: <a href="https://github.com/joyent/illumos-joyent/blob/master/usr/src/tools/scripts/cstyle.pl">cstyle</a></li>
<li>JavaScript: <a href="https://github.com/davepacheco/jsstyle">jsstyle</a>,
<a href="https://code.google.com/closure/utilities/docs/linter_howto.html">gjslint</a></li>
<li>Bash: bashstyle (contained in eng.git:tools/bashstyle)</li>
<li>Makefiles: use bashstyle for now</li>
</ul>

<p>Both cstyle and jsstyle (which are 90% the same code) support overriding style
checks on a per-line and block basis. <code>jsstyle</code> also now supports
configuration options for indent style and few other things. E.g., you
might like this in your Makefile:</p>

<pre><code>JSSTYLE_FLAGS = -o indent=4,doxygen,unparenthesized-return=0
</code></pre>

<p>Options can also be put in a "tools/jsstyle.conf" and passed in with '-f
tools/jsstyle.conf'. See the <a href="https://github.com/davepacheco/jsstyle">jsstyle
README</a>) for details on
JSSTYLED-comments and configuration options.</p>

<p>Note that gjslint can be used as a style checker, but it is <strong>not</strong> a
substitute for javascriptlint. And as with all style checkers, it <strong>must</strong> be
integrated into <code>make check</code>.</p>

<p>Bash scripts and Makefiles must also be checked for style. The only style
guideline for now is the 80-column limit.</p>

<p>Make target: "check"</p>

<h2 id="lint">Lint</h2>

<p>Every C repository <strong>must</strong> run "lint" and every JavaScript repository <strong>must</strong>
run <a href="http://github.com/davepacheco/javascriptlint">javascriptlint</a> and both
<strong>must</strong> be lint-clean. Note that lint is not the same as style: lint covers
objectively dangerous patterns like undeclared variables, while style covers
subjective conventions like spacing.</p>

<p>Both lint and javascriptlint are very configurable. Projects may choose to
enable and disable particular sets of checks as they deem appropriate. Most
checks can be disabled on a per-line basis. As with style, it's recommended
that we minimize divergence between repositories.</p>

<p>Make target: "check"</p>

<h2 id="copyright">Copyright</h2>

<p>All source files (including Makefiles) should have the MPL 2.0 header and a
copyright statement. These statements should match the entries in the
<code>prototypes</code> directory. For an easy way to ensure that new files have the right
MPL 2.0 header and copyright statement, you can copy the corresponding file out
of the <code>prototypes</code> directory in <code>eng.git</code>.</p>

<p>The contents of the MPL 2.0 header must be:</p>

<pre><code>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.
</code></pre>

<p>When modifying existing code, the year should be updated to be the
current year that the file was modified. There should only be a single
year, not a list. For example:</p>

<pre><code>Copyright (c) 2014, Joyent, Inc.
</code></pre>

<h2 id="testing">Testing</h2>

<p>tl;dr: <code>make test</code> for dev environment tests. 'test/runtests' driver script
for in-Triton systems tests (see boilerplate 'tools/runtests.in').</p>

<p>All repos <strong>must</strong> be tested by a comprehensive automated test suite and must
be able to generate TAP output. (No particular node.js test framework is
required, but all things being equal, use "nodeunit" or "node-tap".)
These tests may be repo-specific, or may be part of a broader system test
suite (ideally both). In either case, bug fixes and new features should not
be integrated without adding new tests, and the tests <strong>must</strong> be run
automatically (as via jenkins) either with every commit or daily. Currently
this is handled by the <a href="https://mo.joyent.com/docs/globe-theatre/master/">staging environment</a>
and the "stage-test-*" Jenkins jobs. In other words, your project should
have some sort of "stage-test-*" job. Understanding and fixing failures in
the automated test run <strong>must</strong> be considered the top development priority for
that repo's team.  Persistent failures are not acceptable. Currently, these
staging and CI environments can only be accessed by Joyent employees.</p>

<p>All installed components <strong>should</strong> provide a "runtests" driver script
(preferably in the "test" subdirectory) and the necessary test files
for running system tests (and unit tests are fine too) against your
running service -- as opposed to starting up parallel dev versions of your
service. The goal here is to provide a common, simple, and "just works"
entry point for test components as they are deployed in the product,
for the benefit of QA, continuous-integration testing, and devs not
familiar with a given component. Dev environment != production environment.
All "runtests" scripts <strong>must</strong> exit non-zero if any tests failed.</p>

<p>Q&amp;A:</p>

<ul>
<li><p>Why not just "make test"?</p>

<p>Not all components install (or should install) their Makefile. For example
<code>make</code> isn't available in the headnode GZ. So "runtests" is a lowest common
denominator in this regard. Also dev env != production env -- separate
"make test" and "runtests" entry points can facilitate different test
setup and test case selection, if necessary.</p></li>
<li><p>What about a customer running tests and blowing away production data?!</p>

<p>Each runtests will be prefixed with a kill switch so that 'runtests' will
not be accidentally run on production systems. The kill switch is the
presence of the '/lib/sdc/.sdc-test-no-production-data' file. See
handling in 'tools/runtests.in' boilerplate.</p></li>
<li><p>What's a "system" test? "unit" test?</p>

<ul>
<li>unit tests: Tesing local code, no parts of the "system" are required
to run, and no mocking.</li>
<li>integration tests: Local code, no "system", parts of the system are
mocked out as required.</li>
<li>system tests: Testing the service(s) in a deployed environment.</li>
</ul></li>
</ul>

<h2 id="cscope">cscope</h2>

<p>cscope is a terminal-based tool for browsing source. For performance, it's best
to use it with an index. For repos using this repo's Makefile, you can build a
basic index in a source tree using:</p>

<pre><code># make xref
</code></pre>

<p>which translates to a make recipe something like this:</p>

<pre><code>.PHONY: xref
xref: cscope.files
    $(CSCOPE) -bqR

.PHONY: cscope.files
cscope.files:
    find . -name '*.c' -o -name '*.h' -o -name '*.cc' -o -name '*.js' \
        -o -name '*.s' -o -name '*.cpp' &gt; $@
</code></pre>

<p>You may also want the "-k" flag to cscope, which tells it to ignore standard
header files.</p>

<p>Once the index is built, you can browse the source with:</p>

<pre><code># cscope -dq
</code></pre>

<p>cscope is available for SmartOS in pkgsrc. It's also buildable on MacOS. For
instructions, see <a href="https://hub.joyent.com/wiki/display/dev/Snow+Leopard+tips%2C+fixes+and+bugs">the
wiki</a>.</p>

<p>Make target: "xref"</p>

<h2 id="documentation">Documentation</h2>

<h3 id="api-documentation">API Documentation</h3>

<p>You <strong>must</strong> use <a href="https://github.com/trentm/restdown">restdown</a>. Please discuss
with Trent if this isn't workable for your project.</p>

<p>Restdown is a tool for creating docs (and especially REST API docs) using a
single Markdown file with a few added conventions. You can set it up as
follows. Get the restdown tool:</p>

<pre><code>git submodule add https://github.com/trentm/restdown.git deps/restdown
cd deps/restdown/
git checkout 1.2.15    # let's use a restdown release tag
</code></pre>

<p>Get a starter restdown file:</p>

<pre><code>mkdir -p docs/media/img
cp ../eng/docs/boilerplateapi.md docs/index.md
cp ../eng/docs/media/img/favicon.ico docs/media/img/
cp ../eng/docs/media/img/logo.png docs/media/img/
</code></pre>

<p>Tell the Makefile about it (<code>make docs</code>):</p>

<pre><code>DOC_FILES = index.md
</code></pre>

<h3 id="code-documentation">Code Documentation</h3>

<p>Consider adding a block comment at the top of every file that describes at a
high level the component that's implemented in the file. For example:</p>

<pre><code>/*
 * ca-profile.js: profile support
 *
 * Profiles are sets of metrics. They can be used to limit visibility of
 * metrics based on module, stat, or field names, or to suggest a group of
 * metrics to a user for a particular use case.
 */
</code></pre>

<p>For non-trivial subsystems, consider adding a Big Theory statement that
describes what the component does, the external interface, and internal details.
For a great example, check out
<a href="https://github.com/joyent/illumos-joyent/blob/master/usr/src/uts/common/os/panic.c#L29">panic.c</a>
in the kernel.</p>

<p>Consider keeping design documents in restdown inside the repo. It's okay to have
one-off documents for specific projects, even if they become out of date as the
code evolves, but make clear in the document that the content may be out of
date. Keep such docs separate from general design documents that are kept up to
date.</p>

<h2 id="node-build">Node Build</h2>

<p>If your deployed service or tool uses node, then it <strong>must</strong> provide its own
node build. The exception is services whose upgrade is tied to the Triton
platform, and hence can be tested against a known node build (the platform's
node build). There are two ways you can get a node build for your repo:</p>

<ol>
<li><p>Build your own from sources. Read and use "tools/mk/Makefile.node.defs" and
"tools/mk/Makefile.node.targ". You'll also need a git submodule of the node
sources:</p>

<pre class="shell"><code>git submodule add https://github.com/joyent/node.git deps/node
$ cd deps/node
$ git checkout v0.6.18   # select whichever version you want
</code></pre></li>
<li><p>Use a prebuilt node. Read and use "tools/mk/Makefile.node_prebuilt.defs"
and "tools/mk/Makefile.node_prebuilt.targ".</p></li>
</ol>

<h2 id="managing-node-dependencies">Managing Node Dependencies</h2>

<p>There are three cases for Node dependencies:</p>

<ul>
<li>external public dependencies (e.g., restify, express): specify these in
package.json as usual and shrinkwrap them.</li>
<li>internal (Joyent-private) dependencies (e.g., ca-vis): either specify these in
package.json using git URLs instead of version numbers, or use git submodules
and treat these as local (repo-private) dependencies (see below). All things
being equal, prefer git URLs in package.json to git submodules. In all cases,
use shrinkwrap.</li>
<li>local, repo-private dependencies (e.g., ca-native in cloud-analytics or amon
modules): During the build process, run "npm install path/to/dep". <strong>This
approach should only be used for code that lives inside the repo but is
installed as a separate package for whatever reason. This does not apply to
most dependencies. Most dependencies should not be checked into git.</strong></li>
</ul>

<p>Shrinkwrapping: all dependendencies that come from outside the repo should be
shrinkwrapped. See <a href="http://npmjs.org/doc/shrinkwrap.html">npm shrinkwrap</a> for
details.</p>

<p>Shrinkwrap is available in npm 1.1.2, which is bundled with node 0.6.12.
However, proper support for git SHAs in shrinkwrap didn't land until the next
version. If you're stuck on 1.1.2, you can still use git SHAs in the shrinkwrap
file, but you'll have to specify them by hand.</p>

<h2 id="node-add-ons-binary-modules">Node add-ons (binary modules)</h2>

<p>Because C++ does not define a useful compiler- or platform-dependent
<a href="http://stackoverflow.com/questions/7492180/c-abi-issues-list">binary</a>
<a href="http://developers.sun.com/solaris/articles/CC_abi/CC_abi_content.html">interface</a>,
and we have seen breakage resulting from changing compiler versions, any repo
that uses add-ons (binary modules) <strong>must</strong> bundle its own copy of "node" and
use that copy at runtime. And almost every repo will fall into this bucket,
since we use the native node-dtrace-provider heavily for observability.</p>

<p>The recommended way to do this is to add the official node repo as a git
submodule and build it during the build process. There are existing modular
Makefiles in this repo (eng.git) to do all the work. All you need to do is
include them and then add the appropriate dependencies on <code>$(NODE)</code>.</p>

<h2 id="commit-comments-and-jira-tickets">Commit Comments and JIRA Tickets</h2>

<p>In collaborating on a body of software as large as Triton, it's critical that
the issues and thought processes behind non-trivial code changes be documented,
whether that's through code comments, git commit comments, or JIRA tickets.
There are many cases where people other than the original author need to
examine the git log:</p>

<ul>
<li>An engineer in another area tries to understand a bug they've run into (in
your repo or not), possibly as a result of a recent change. The easier it is
for people to move between repos and understand recent changes, the more
quickly bugs in master can be root-caused. This is particularly important to
avoid an issue bouncing around between teams where the problem is <em>not</em>.</li>
<li>An engineer in another area tries to understand when a feature or bugfix
was integrated into your repo so that they can pull it down to use it.</li>
<li>An engineer working on the same code base, possibly years later, needs to
modify (or even rewrite) the same code to fix another bug. They need to
understand why a particular change was made the way it was to avoid
reintroducing the original bug (or introducing a new bug).</li>
<li>A release engineer tries to better understand the risk and test impact of a
change to decide whether it's appropriate to backport.</li>
<li>A support engineer tries to better understand the risk and test impact of a
change to decide whether it's appropriate for binary relief or hot patching.</li>
<li>Product management wants to determine when a feature or bugfix was integrated.</li>
<li>Automated tools want to connect commits to JIRA tickets.</li>
</ul>

<p>To this end, we require that with every commit there <strong>must</strong> be a comment that
includes the list of JIRA tickets addressed with this commit and a synopsis of
the changes (<em>either</em> for the whole commit <em>or</em> for each change, one by one).
<strong>Between the JIRA ticket and the commit comment itself, there must be
sufficient information for an engineer that's moderately familiar with the code
base, possibly years later but with source in hand, to understand how and why
the change was made.</strong></p>

<p>The worst case is when the thought process and issue list are nowhere: not in
the comments and not in the JIRA tickets.</p>

<h3 id="commit-comments">Commit Comments</h3>

<p>Across Joyent we require that <strong>each commit be associated with one or more JIRA
tickets and that those tickets be listed in the commit comments</strong>. This way,
given either the commit or the JIRA ticket, one can find the other.</p>

<p>Historically, some repos (notably illumos-joyent and cloud-analytics) have
additionally required that tickets must not be reused for multiple commits in
the same repo except for very minor changes like fixing lint or style warnings.
This makes it easier to correlate tickets and commits, since there's usually
exactly one commit for each resolved ticket. It also makes it easier to
back out the changes for a particular project. For these repos, the git
comments for the commit consist of a single line per JIRA ticket being resolved
in the commit. Each line consists of the ticket identifier and the synopsis
exactly as it appears in JIRA (optionally truncated to 80 characters with
"..."):</p>

<pre><code>OS-147 vfsstat command to show VFS activity by zone
OS-148 Update ziostat to coexist peacefully with vfsstat
OS-149 New kstats to support vfsstat
</code></pre>

<p>This approach encourages short, descriptive ticket synopses. For repos that keep
track of code reviews (e.g., illumos-joyent), that information is appended like
this:</p>

<pre><code>OS-850 Add support for Intel copper quad I350 to igb.
Reviewed by: Jerry Jelinek &lt;jerry.jelinek@joyent.com&gt;
</code></pre>

<p>In the rare cases where the same ticket is used for multiple commits, a
parenthetical is used to explain why:</p>

<pre><code>INTRO-581 move mdb_v8 into illumos-joyent (missing file)
</code></pre>

<p>This structure works well for established repos like illumos, but it's not
always appropriate. For new work on greenfield projects, it may not even make
sense to use more than one ticket until the project reaches a first milestone.</p>

<h3 id="jira-tickets">JIRA Tickets</h3>

<p>For bugs, especially those that a customer could hit, consider including
additional information in the JIRA ticket:</p>

<ul>
<li>An explanation of what happened and the root cause, referencing the source
where appropriate. This can be useful to engineers debugging similar issues
or working on the same area of code who want to understand exactly why a
change was made.</li>
<li>An explanation of how to tell if you've hit this issue. This can be pretty
technical (log entries, tools to run, etc.). This can be useful for engineers
to tell if they've hit this bug in development as well as whether a customer
has hit the bug.</li>
<li>A workaround, if any.</li>
</ul>

<p>Of course, much of this information won't make sense for many bugs, so use your
judgment, but don't assume that you're the only person who will ever look at the
ticket.</p>

<h1 id="logging">Logging</h1>

<p>There are at least three different consumers for a service's logs:</p>

<ul>
<li>engineers debugging issues related to the service (which may not actually be
problems with the service)</li>
<li>monitoring tools that alert operators based on error events or levels of
service activity</li>
<li>non real-time analysis tools examining API activity to understand performance
and workload characteristics and how people use the service</li>
</ul>

<p>For the debugging use case, <strong>the goal should be to have enough information
available after a crash or an individual error to debug the problem from the
very first occurrence in the field</strong>. It should also be possible for engineers
to manually dump the same information as needed to debug non-fatal failures.</p>

<p>Triton service logs <strong>must</strong> be formatted in JSON. Node.js services <strong>must</strong>
use <a href="https://github.com/trentm/node-bunyan">Bunyan</a>. Exceptions: (a) you are
using syslog (see use case for syslog below); (b) your service is legacy; or,
(c) you just haven't migrated to Bunyan yet (which is fine, JSON log output
is not a top-priority make work project). If you have an example of a log for
which JSON format gets in the way, please bring it up for discussion).</p>

<p>Multiple use cases do not require multiple log files. Most services should log
all activity (debugging, errors, and API activity) in JSON to either the SMF
log or into a separate log file in
"/var/smartdc/&lt;service&gt;/log/&lt;component&gt;.log". For services with
extraordinarily high volume for which it makes sense to separate out API
activity into a separate file, that should be directed to
"/var/smartdc/&lt;service&gt;/log/requests.log". However, don't use separate
log files unless you're sure you need it. All log files in
"/var/smartdc/&lt;service&gt;/log" should be configured for appropriate log
rotation.</p>

<p>For any log entries generated while handling a particular request, the log
entry <strong>must</strong> include the request id. See "Request Identifiers" under "REST
API Guidelines" below.</p>

<p>Log record fields <strong>must</strong> conform to the following (most of which comes
for free with Bunyan usage):</p>

<table>
<thead>
<tr>
  <th>JSON key</th>
  <th>Description</th>
  <th>Examples</th>
  <th>Required</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>name</strong></td>
  <td>Service name.</td>
  <td>"ca" (for Cloud Analytics)</td>
  <td>All entries</td>
</tr>
<tr>
  <td><strong>hostname</strong></td>
  <td>Server hostname.</td>
  <td><code>uname -n</code>, <code>os.hostname()</code></td>
  <td>All entries</td>
</tr>
<tr>
  <td><strong>pid</strong></td>
  <td>Process id.</td>
  <td>1234</td>
  <td>All entries</td>
</tr>
<tr>
  <td><strong>time</strong></td>
  <td><code>YYYY-MM-DDThh:mm:ss.sssZ</code></td>
  <td>"2012-01-26T19:20:30.450Z"</td>
  <td>All entries</td>
</tr>
<tr>
  <td><strong>level</strong></td>
  <td>Log level.</td>
  <td>"fatal", "error", "warn", "info", or "debug"</td>
  <td>All entries</td>
</tr>
<tr>
  <td><strong>msg</strong></td>
  <td>The log message</td>
  <td>"illegal argument: parameter 'foo' must be an integer"</td>
  <td>All entries</td>
</tr>
<tr>
  <td><strong>component</strong></td>
  <td>Service component. A sub-name on the Logger "name".</td>
  <td>"aggregator-12"</td>
  <td>Optional</td>
</tr>
<tr>
  <td><strong>req_id</strong></td>
  <td>Request UUID</td>
  <td>See "Request Identifiers" section below. Restify simplifies this.</td>
  <td>All entries relating to a particular request</td>
</tr>
<tr>
  <td><strong>latency</strong></td>
  <td>Time of request in milliseconds</td>
  <td>155</td>
  <td>Strongly suggested for entries describing the completion of a request or other backend operation</td>
</tr>
<tr>
  <td><strong>req</strong></td>
  <td>HTTP request</td>
  <td>--</td>
  <td>At least once as per Restify's or <a href="https://github.com/trentm/node-bunyan/blob/master/lib/bunyan.js#L856-870">Bunyan's serializer</a> for each request.</td>
</tr>
<tr>
  <td><strong>res</strong></td>
  <td>HTTP response</td>
  <td>--</td>
  <td>At least once as per Restify's or <a href="https://github.com/trentm/node-bunyan/blob/master/lib/bunyan.js#L872-878">Bunyan's serializer</a> for each response.</td>
</tr>
</tbody>
</table>

<p>We use these definitions for log levels:</p>

<ul>
<li>"fatal" (60): The service/app is going to stop or become unusable now.
An operator should definitely look into this soon.</li>
<li>"error" (50): Fatal for a particular request, but the service/app continues
servicing other requests. An operator should look at this soon(ish).</li>
<li>"warn" (40): A note on something that should probably be looked at by an
operator eventually.</li>
<li>"info" (30): Detail on regular operation.</li>
<li>"debug" (20): Anything else, i.e. too verbose to be included in "info" level.</li>
<li>"trace" (10): Logging from external libraries used by your app or <em>very</em>
detailed application logging.</li>
</ul>

<p>Suggestions: Use "debug" sparingly. Information that will be useful to debug
errors <em>post mortem</em> should usually be included in "info" messages if it's
generally relevant or else with the corresponding "error" event. Don't rely
on spewing mostly irrelevant debug messages all the time and sifting through
them when an error occurs.</p>

<p>Most of the time, different services should log to different files. But in some
cases it's desirable for multiple consumers to log to the same file, as for
vmadm and vmadmd. For such cases, syslog is an appropriate choice for logging
since it handles synchronization automatically. Care must be taken to support
entries longer than 1024 characters.</p>

<h1 id="smf-integration">SMF Integration</h1>

<p>All services <strong>must</strong> be delivered as SMF services. This means:</p>

<ul>
<li>They deliver an SMF service manifest.</li>
<li>The install mechanism imports the manifest.</li>
<li>The uninstall mechanism deletes the service.</li>
<li>The service is started, stopped, restarted, etc. via SMF.</li>
</ul>

<p>While SMF itself is grimy and the documentation is far from perfect, the
documentation <em>is</em> extensive and useful. Many common misunderstandings about
how SMF works are addressed in the documentation. It's strongly recommended
that you take a pass through the docs before starting the SMF integration for
your service. In order of importance, check out:</p>

<ul>
<li>SMF concepts: smf(5), smf_restarter(5), smf_method(5), svc.startd(1M)</li>
<li>Tools: svcs(1), svcadm(1M), svccfg(1M)</li>
</ul>

<p>Common mistakes include:</p>

<ul>
<li>Setting the start method to run the program you care about (e.g., "node
foo.js") rather than backgrounding it (e.g., "node foo.js &amp;"). SMF expects
the start method to start the service, not <em>be</em> the service. It times out
start methods that don't complete, so if you do this you'll find that your
service is killed after some default timeout interval. After this happens
three times, SMF moves the service into maintenance.</li>
<li>Using "child" or "wait model" services to avoid the above problem. Read the
documentation carefully; this probably doesn't do what you want. In
particular, if your "wait model" service fails repeatedly, SMF will never put
it into maintenance. It will just loop forever, forking and exiting.</li>
<li>Not using "-s" with svcadm enable/disable. Without "-s", these commands are
asynchronous, which means the service may not be running when "svcadm enable"
returns. If you really care about this, you should check the service itself
for liveness, not rely on SMF, since the start method may have completed
before the service has opened its TCP socket (for example).</li>
</ul>

<h2 id="managing-processes-under-smf">Managing processes under SMF</h2>

<p>SMF manages processes using an OS mechanism called contracts. See contract(4)
for details. The upshot is that it can reliably tell when a process is no
longer running, and it can also track child processes.</p>

<p>Quoting svc.startd(1M):</p>

<pre><code> A contract model service fails if any of the following conditions
 occur:

     o    all processes in the service exit

     o    any processes in the service produce a core dump

     o    a process outside the service sends a service process a
          fatal signal (for example, an administrator terminates a
          service process with the pkill command)
</code></pre>

<p>Notice that if your service forks a process and <em>that</em> process exits,
successfully or otherwise, SMF will not consider that a service failure. One
common mistake here is forking a process that will be part of your service, but
not considering what happens when that process fails (exits). SMF will not
restart your service, so you'll have to manage that somehow.</p>

<h2 id="service-logs">Service logs</h2>

<p>SMF maintains a log for each service in /var/svc/log. The system logs restarter
events here and launches the start method with stderr redirected to the log,
which often means the service itself will have stderr going to this log as
well. It's recommended that services either use this log for free-form debug
output or use the standard logging facility described under "Logging" above.</p>

<h1 id="rest-api-guidelines">REST API Guidelines</h1>

<p>It's strongly recommended to use
<a href="https://github.com/mcavage/node-restify">restify</a> for all web services. Not
only will you leverage common code and test coverage, but restify gives you
features like DTrace observability, debuggability, throttling, and versioning
out of the box. If it doesn't support something you need, consider adding it
rather than rolling your own.</p>

<h2 id="request-identifiers">Request Identifiers</h2>

<p>A request identifier uniquely identifies an operation across multiple services
(e.g., portal, cloudapi, ca, ufds). It's essential for debugging issues after
they've happened. The goal is for issues to be debuggable from the information
available after their first occurrence, without having to reproduce it to
gather more information. To facilitate this:</p>

<ul>
<li>When an external service receives a request from the outside, it <strong>must</strong>
generate a unique request identifier and include it in the "x-request-id"
header of any requests made as part of handling the initial request.</li>
<li>When any service receives a request with an "x-request-id" header, it
<strong>must</strong> include it in the "x-request-id" header of any request made as part
of handling that request.</li>
<li>When each service logs activity (API requests), alerts, or debug messages
related to a particular request, it <strong>must</strong> include the request id as
the "req_id" field (as described in the <a href="https://github.com/trentm/bunyan">Bunyan
docs</a>).</li>
</ul>

<h2 id="naming-endpoints">Naming Endpoints</h2>

<p>Service API endpoints <strong>should</strong> be named. Endpoint names <strong>must</strong> be
CamelCase, <strong>should</strong> include the name of resource being operated on,
and <strong>should</strong> follow the lead of
<a href="https://apidocs.joyent.com/cloudapi/">CloudAPI</a> for verb usage, e.g.:</p>

<pre><code># CRUD examples:
ListMachines
GetMachine
CreateMachine
DeleteMachine

# Other actions, if applicable:
StopMachine
StartMachine
RebootMachine
ResizeMachine

# Example using "Put" verb from
# &lt;https://apidocs.joyent.com/manta/api.html#PutObject&gt; when the action
# is idempotent.
PutObject
</code></pre>

<h2 id="error-handling">Error Handling</h2>

<p>APIs must provide meaningful and actionable error responses, especially for
requests that involve submitting data (i.e. non-GET requests). "Actionable"
here means that enough information is provided for programmatic handling of
errors.</p>

<h3 id="motivation">Motivation</h3>

<p><a href="http://mcavage.github.com/node-restify/#Error-handling">Node-restify error support</a>
provides a set of <code>RestError</code> classes with a typical response like:</p>

<pre><code>HTTP/1.1 409 Conflict
...

{
  "code": "InvalidArgument",
  "message": "I just don't like you"
}
</code></pre>

<p>However, API clients often need more information about the failure of a
request. This scheme does not provide a way to programmatically match a
failure to one of multiple input parameters. E.g., consider a client
attempting to present errors in a form for a "CreateFoo" endpoint.</p>

<p>E.g., API clients that implement user interfaces need to give users
feedback about the errors produced after submitting a form, where a message
such as "RAM must be greater than 1024" is more useful than "Arguments are
invalid" messages produced by generic <em>node restify</em> server implementations.</p>

<h3 id="error-response-format">Error Response Format</h3>

<pre><code>HTTP/1.1 &lt;statusCode&gt; ...
...

{
  "code": "&lt;restCode&gt;",
  "message": "&lt;message&gt;",
  "errors": [
    {
      "field": "&lt;errorField&gt;",
      "code": "&lt;errorCode&gt;",
      "message": "&lt;errorMessage&gt;"
    },
    ...
  ]
}
</code></pre>

<p>JEG-based API error response guidelines:</p>

<ul>
<li><strong>must</strong> use a meaningful HTTP <code>statusCode</code>. See
<a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">http://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a>.</li>
<li><strong>must</strong> include a <code>code</code> CamelCase string code field</li>
<li><strong>must</strong> include a <code>message</code> string description of the error. The
message must be a human readable string that allows users to understand
the nature of the error <em>code</em>, as the same error <em>code</em> can be produced
with two different <em>messages</em>. An example of this might be an
"InternalError" <em>code</em> that could return "Database if offline" or "Cache
not running" as its <em>message</em>.</li>
<li><strong>may</strong> include an <code>errors</code> array. Each element of that array <strong>must</strong>
include a <code>field</code> name, <strong>must</strong> include a <code>code</code> CamelCase string code
field and <strong>may</strong> include a <code>message</code> string field.</li>
</ul>

<p>Suggested <code>errors.*.code</code> fields are:</p>

<table>
<thead>
<tr>
  <th>Code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Missing</td>
  <td>The resource does not exist.</td>
</tr>
<tr>
  <td>MissingParameter</td>
  <td>A required parameter was not provided.</td>
</tr>
<tr>
  <td>Invalid</td>
  <td>The formatting of the field is invalid.</td>
</tr>
</tbody>
</table>

<h3 id="example">Example:</h3>

<pre><code>HTTP/1.1 422 Unprocessable Entity
...

{
  "code": "InvalidParameters",
  "message": "Invalid paramaters to create a VM",
  "errors": [
    {
      "field": "ram",
      "code": "Invalid",
      "message": "RAM is not a number"
    },
    {
      "field": "brand",
      "code": "MissingParameter"
    },
    {
      "field": "image_uuid",
      "code": "Missing",
      "message": "Image '6b288017-2c2d-354b-83d4-69748d50284d' does not exist"
    }
  ]
}
</code></pre>

<h3 id="best-practice">Best Practice</h3>

<p>TODO: Trent is working on code to use with restify v2.0 to facilitate
subclassing restify.RestError to make the above simpler.</p>

<h3 id="documenting-errors">Documenting Errors</h3>

<p>An API <strong>must</strong> document all of the <code>restCodes</code> it can produce. An "Errors"
section near the top of the API's restdown docs is suggested. For example:</p>

<pre><code>||**HTTP Status Code**||**JSON Code**||**Description**||
||400||OperationNotAllowedOnRootDirectory||Trying to call PUT on `/`||
||404||ResourceNotFound||If `:account` does not exist||
||409||EntityExists||If the specifed path already exists and is not a directory||
||409||ParentNotDirectory||Trying to create a directory under an object||
</code></pre>

<p>Additionally, each endpoint <strong>must</strong> document all custom <code>errors.*.code</code>
values it can produce. If just a stock set of error codes is used, then
it is sufficient to document those in the "Errors" section at the top
of the API docs.</p>

<h1 id="bash-programming-guidelines">Bash programming guidelines</h1>

<h2 id="xtrace">xtrace</h2>

<p>Bash has a very useful feature called "xtrace" that causes it to emit
information about each expression that it evaluates. You can enable it for a
script with:</p>

<pre><code>set -o xtrace
</code></pre>

<p>With newer versions, you can redirect this output somewhere other than stderr
by setting
<a href="https://www.gnu.org/software/bash/manual/bashref.html#Bash-Variables">BASH_XTRACEFD</a>.</p>

<p>This is incredibly useful for several situations:</p>

<ul>
<li>debugging non-interactive system scripts (e.g., SMF start methods) <em>post
mortem</em>. Such scripts should leave xtrace on all the time, since they're not
run frequently enough for the extra logging to become a problem and the
xtrace output makes it significantly easier to understand what happened when
these scripts go wrong.</li>
<li>debugging interactive scripts in development. You can run bash with "-x" to
enable xtrace for a single run. You usually don't want to leave xtrace on for
interactive scripts, unless you redirect the xtrace output:</li>
<li>debugging interactive scripts <em>post mortem</em> by enabling the xtrace output and
redirecting it to a temporary file. Be sure to remove the file when the
script exits successfully.</li>
</ul>

<h2 id="error-handling-2">Error handling</h2>

<p>It's absolutely possible to write robust shell scripts, but the default shell
behavior to ignore errors means you have to consider how to handle errors in
order to avoid creating brittle scripts that are difficult to debug.</p>

<p>The biggest hammer is the "errexit" option, which you can enable with:</p>

<pre><code>set -o errexit
</code></pre>

<p>This will cause the program to exit when simple commands, pipelines, and
subshells return non-zero. Commands invoked in a conditional test, a loop test,
or as part of an <code>&amp;&amp;</code> or <code>||</code> list do not get this special treatment. While this
approach is nice because the default is that errors are fatal (so it's harder to
forget to handle them), it's not a silver bullet and doesn't let you forget
about error handling completely. For example, many commands <em>can</em> reasonably
fail with no ill effects and so must be explicitly modified with the unfortunate
<code>|| true</code> to keep errexit happy.</p>

<p>A more fine-grained approach is to explicitly check for failure of invocations
that may reasonably fail. A concise pattern is to define a <code>fail</code> function
which emits its arguments to stderr and exits with failure:</p>

<pre><code>function fail()
{
    echo "$*" &gt;&amp;2
    exit 1
}
</code></pre>

<p>and then use it like this:</p>

<pre><code>echo "about to do something that might fail"
zfs create zones/myfilesystem || fail "failed to create zones"
</code></pre>

<p>You can also use this with variable assignments</p>

<pre><code>echo "about to list contents of a directory that may not exist"
foo=$(ls -1 $tmpdir) || fail "failed to list contents of '$tmpdir'"
</code></pre>

<p>It's also important to remember how error handling works with pipelines. From
the Bash manual:</p>

<pre><code>The exit status of a pipeline is the exit status of the last command in the
pipeline, unless the pipefail option is enabled (see The Set Builtin). If
pipefail is enabled, the pipeline's return status is the value of the last
(rightmost) command to exit with a non-zero status, or zero if all commands
exit successfully.
</code></pre>

<p>This means that if you run this to look for compressed datasets:</p>

<pre><code># zfs list -oname,compression | grep on
</code></pre>

<p>If the "zfs" command bails out partway through, that pipeline will still
succeed (unless pipefail is set) because "grep" will succeed. To set pipefail,
use:</p>

<pre><code>set -o pipefail
</code></pre>

<h2 id="running-subcommands">Running subcommands</h2>

<p>Prefer <code>$(subcommand)</code> to <code>`subcommand`</code>, since it can be nested:</p>

<pre><code>type_of_grep=$(file $(which grep))
</code></pre>

<h2 id="automatic-checks">Automatic Checks</h2>

<p>See "Coding Style" above for style checks. Currently, the only enforced check
is an 80-column limit on line length.</p>

<p>It's also worth using "bash -n" to check the syntax of bash scripts as part of
your Makefile's "check" target. The Makefiles in eng.git automatically check
both syntax and style.</p>

<h2 id="temporary-files">Temporary Files</h2>

<p>Put temporary files in /var/tmp/<code>$(dirname $0)</code>.<code>$$</code>. This will generally be
unique but also allows people to figure out what script left this output
around.</p>

<p>On successful invocations, remove any such temporary directories or files,
though consider supporting a <code>-k</code> flag (or similar) to keep the temporary files
from a successful run.</p>

<h2 id="parsing-command-line-options">Parsing command line options</h2>

<p>By convention, illumos scripts tend to use <code>opt_X</code> variables to store the value
of the <code>-X</code> option (e.g., <code>opt_d</code> for <code>-d</code>). Options are best parsed with
getopts(1) (not to be confused with getopt(1)) using a block like this:</p>

<pre><code>function usage
{
    [[ $# -gt 0 ]] &amp;&amp; echo "$(dirname $0): $*" &gt;&amp;2

    cat &lt;&lt;-USAGE &gt;&amp;2
    Usage: $(dirname $0) [-fn] [-d argument] args ...

    Frobs args (optionally with argument &lt;argument&gt;).

    -f    force frobnification in the face of errors
    -n    dry-run (don't actually do anything)
    -d    specify temporary directory
    USAGE

    exit 2
}

opt_f=false
opt_n=false
opt_d=

while getopts ":fnd:" c; do
        case "$c" in
        f|n)    eval opt_$c=true                                ;;
        d)      eval opt_$c=$OPTARG                             ;;
        :)      usage "option requires an argument -- $OPTARG"  ;;
        *)      usage "illegal option -- $OPTARG"               ;;
        esac
done

# Set $1, $2, ... to the rest of the arguments.
shift $((OPTIND - 1))
</code></pre>

<p>Below are common command line options. If you're implementing the functionality
below, try to stick to the same option letters to maintain consistency. Of
course, many of these options won't apply to most tools.</p>

<pre><code>-?          Display usage message.
-d dir      Use directory "dir" for temporary files
-i          Interactive mode (force confirmation)
-f          Barrel on in the face of errors
-k          Keep temporary files (for debugging)
-n          Dry-run: print out what would be done, but don't do it
-o file     Specify output file
-p pid      Specify process identifiers
-r          Recursive mode
-y          Non-interactive mode (override confirmations with "yes")
-z          Generate (or extract) a compressed artifact
</code></pre>

<h2 id="command-line-scripts-that-perform-multiple-complex-tasks">Command-line scripts that perform multiple complex tasks</h2>

<p>With xpg_echo, you can use "\c" with "echo" to avoid printing a newline.
Combined with the above error handling pattern, you can write clean scripts
that perform a bunch of tasks in series:</p>

<pre><code>shopt -s xpg_echo

echo "Setting nodename to 'devel' ... \c"
hostname devel || fail "failed to set hostname"
echo "done."

echo "Testing DNS ... \c"
ping example.com || fail "failed"

echo "Restarting ssh ... \c"
svcadm disable -s ssh || fail "failed to disable service"
svcadm enable -s ssh || fail "failed to enable service"
echo "done."
</code></pre>

<p>The output is clean both when it succeeds:</p>

<pre><code># ./setup.sh
Setting nodename to 'devel' ... done.
Testing DNS ... example.com is alive
Restarting ssh ... done.
</code></pre>

<p>and when it fails:</p>

<pre><code># ./setup.sh
Setting nodename to 'devel' ... done.
Testing DNS ... ping: unknown host example.com
failed
</code></pre>

<p>This is primarily useful for complex scripts that people run interactively
rather than system scripts whose output goes to a log.</p>

<h1 id="jira-best-practices-for-customer-issues">JIRA best practices for Customer Issues</h1>

<p>We have all noticed that there are a lot more JIRA tickets originating from
customers than there were 6 months ago.</p>

<p>We need to refine the process of opening, updating, and resolving bugs so that
we maximize productivity, and reduce the time that bugs sit idle with not
enough information to act on.</p>

<h2 id="jira-updates">JIRA Updates</h2>

<p>Providing regular updates to JIRA tickets is the best way to keep stakeholders
informed on the progress of the issue. A little more effort spent updating
JIRA issues will create a valuable knowledge base full of information for the
Ops and Support teams to use. The result will be:</p>

<ol>
<li><p>Fewer issues coming through to the Dev team, as issues that have been worked
through before will be able to be triaged before they are passed to
engineering. We are are shooting for a 10:1 ratio of issues opened to
issues passed to engineering. Currently were well over 10:5.</p></li>
<li><p>Issues that are passed to engineering have had more diagnostic information
in them, as the Ops and Support teams learn from example on how to
troubleshoot issues. This will reduce the time it takes for you to resolve
issues, leaving you more time to work on more interesting projects.</p></li>
<li><p>Better customer relations, as the customer teams will be able to explain to
the customers what steps are being taken to find them a solution to their
problem.</p></li>
</ol>

<h3 id="assigning-tickets">Assigning Tickets</h3>

<p><img src="media/img/assign_to_me.jpg" alt="Assign To Me" /></p>

<p>Its important to make sure that active tickets (tickets that someone is
working on) have an Assignee. The way that the triage teams decide if something
needs to be escalated to engineering triage is using this field. If there is no
one assigned to an issue, Ben and Deniz will continue to ask for a triage in
scrum. So if youre working on an issue, even if you dont intend to be the
final owner, click the Assign to me button in the top nav. This will indicate
that weve had eyes on this issue and its not sitting idle. You can always
reassign the issue if something changes.</p>

<h3 id="needs-more-info">Needs More Info</h3>

<p><img src="media/img/needs_more_info.jpg" alt="Needs More Info" /></p>

<p>Needs More Info is a custom status that we added last year to indicate that
there is not enough information to proceed on an issue. This could be used both
for development, when there is not enough info to troubleshoot, or by the
customer teams, if there is not enough info to resolve the issue with the
customer. Whenever you put a ticket into this state, make sure to assign the
ticket to whoever needs to provide the info. In your case, this will often be
the reporter. It is important to force a ticket into this status if you are
blocked on proceeding with diagnostics due to lack of information.</p>

<h3 id="comments">Comments</h3>

<p><img src="media/img/comments.jpg" alt="Comments" /></p>

<p>Commenting is important to keep our cross-functional teams aware of progress
made (or not made) on the resolution of a customer issue. Commenting best
practices:</p>

<ul>
<li>Comment often, even if you dont have all of the details worked out yet. The
more information provided the more informed we can make the customers.</li>
<li>Comment instructionally, as if you were explaining to someone else how you
diagnosed the issue. This will help the Ops and Support teams to be able to
recognize, categorize and help diagnose issues on their own in the future,
saving everyone time and energy.</li>
<li>Comment consistently, at the end of the work day, for instance. Even if the
comment is that you made little progress, it keeps the customer facing teams
informed of whats going on, so that they can make an informed decision on
what to communicate back to the customer.</li>
</ul>

<h3 id="moving-tickets">Moving Tickets</h3>

<p>Often a ticket will come in through the JPC project, but logically belongs in
another, as the problem needs to be resolved in Triton.</p>

<p>For issues like this, please use the Move feature to move the ticket into the
appropriate project. The JPC ticket will then automatically redirect users to
the new location.</p>

<p><img src="media/img/move_ticket.jpg" alt="Move Ticket" /></p>

<h3 id="linking-tickets">Linking Tickets</h3>

<p>When an issue is either related to, or a duplicate of , or depends on a ticket
that is already in the system, its valuable to link the 2 tickets in JIRA. You
can do this using the Link feature:</p>

<p><img src="media/img/linking_tickets.jpg" alt="Linking Tickets" /></p>

<p>The linked issue(s) will then show up in the ticket as a separate section:</p>

<p><img src="media/img/issue_links.jpg" alt="Issue Links" /></p>

<h3 id="field-target-fix-version">Field: <code>Target Fix Version</code></h3>

<p>If you are working on an issue, it is important to know what release you are
targeting for the fix. Typically, you will either be targeting a Simpsons
version (meaning that the release to the customer would be the next major), or
a dot release. Bryan and Laurel can help clarify which release your fix should
go into if you are unsure.</p>

<p>Note: The JPC project only contains dot release versions. If something is more
suited for a Simpsons release version, you should move the ticket to another
project.</p>

<p>The customer teams will use this information to decide whether they can wait
for the fix in the next release, or if theyll need to find a short term work
around.</p>

<p><img src="media/img/fix_version.jpg" alt="Target Fix Version" /></p>

<h2 id="resolving-jira-tickets">Resolving JIRA Tickets</h2>

<p>Issue resolutions should provide valuable information to the customer teams,
allowing them to communicate solutions back to our customers, as well as make
decisions on patches and workarounds.</p>

<p>Please spend some extra time when resolving bugs that originated from a
customer.</p>

<h3 id="field-issue-resolution-public">Field: <code>Issue Resolution (Public)</code></h3>

<p>The Issue Resolution field is the field that the customer teams are going to
use to communicate information back to their customers about the bug fix.</p>

<p>This field must be filled out upon resolution if the ticket has originated from
a customer (either coming from the JPC project or having a customer label
attached to it).</p>

<p>When you are filling in this field, try to word it as though you are talking to
the customer. The customer doesnt need to know every detail of how the issue
was resolved, but they do want to know how it will impact them.</p>

<p><img src="media/img/resolution.jpg" alt="Resolution" /></p>

<h3 id="field-resolution">Field: <code>Resolution</code></h3>

<p>Resolving a ticket once youve committed code indicates to the customer teams
that they can deliver a solution (or estimated release date) to the customer.
It is important to resolve your issues so that we continue to rotate bugs out
of the queue, and keep our customers happy.</p>

<table>
<thead>
<tr>
  <th>Resolution</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Fixed/Implemented</td>
  <td>Indicates that a development solution has been implemented and can be communicated to the customer. Release date can be deduced from the fix version.</td>
</tr>
<tr>
  <td>Duplicate</td>
  <td>Indicates that this is already being worked on (or has been fixed) by another bug. Please Link the duplicate issue to the ticket.</td>
</tr>
<tr>
  <td>Won't Fix</td>
  <td>There are certain circumstances under which we will decline to resolve a customer issue. A couple examples of this are if the issue being raised occurs by design, if we are refactoring a part of the code base that will eliminate the bug once released, or if there is a sufficient workaround. Bryan and Laurel should be consulted if you think a bug is a "won't fix", and always include an explanation for the customer teams if you use this resolution on a ticket that originated from a customer.</td>
</tr>
</tbody>
</table>

<h3 id="field-fix-versions">Field: <code>Fix Version/s</code></h3>

<p>Fix version is the version in which you actually committed the code that fixed
the bug. It differs from Target Fix Version in that it should only be added to
the ticket after resolution. The fix version is what the customer teams will
use to decide whether or not a patch is required on the current operating
version.</p>

<p><img src="media/img/fix_version.jpg" alt="Fix Version" /></p>

<h1 id="writing-makefiles">Writing Makefiles</h1>

<p>This repo (eng.git) provides a number of modular Makefiles which you can use
(perhaps even by direct reference using submodules) to provide the required
targets described above, as well as several other useful pieces (like building
Node in your repo). These are designed to be dropped in without modification:
they consume Make variables as input and either export other variables or define
rules. You should use these existing Makefiles wherever possible.</p>

<p>Importantly:</p>

<ul>
<li>If you find yourself adding anything other than a repo-specific variable
definition or a repo-specific rule to your Makefile, consider creating a
new Makefile with a crisp interface and adding it to the existing ones in
eng.git. We want to avoid Makefile code duplication just as we would
JavaScript code duplication.</li>
<li>Do <strong>not</strong> modify a copy of any of the existing sub Makefiles from eng.git.
Feel free to generalize or improve the original, but don't fork it.</li>
<li>We do not use recursive Make. Avoid it within a project if at all possible.</li>
</ul>

<p>Top level Makefiles should generally have the following structure:</p>

<ol>
<li>Repo-specific definitions. These serve as inputs for included Makefiles. For
example, you might define the list of JavaScript files that should be
style-checked here.</li>
<li>Includes for Makefiles that define variables based on the repo-specific
variables (e.g., repo specifies input files, and the included Makefile
defines a list of output files, or modifies the list of files that will be
removed with "make clean").</li>
<li>Repo-specific rules. These must be the first rules that appear in the
Makefile so that the repo can control the default target and the order of
dependencies for common targets.</li>
<li>Includes for Makefiles that define other rules.</li>
</ol>

<p>The goal is that most top-level Makefiles only specify their parameters, the
repo-specific rules, and which other Makefiles get included to do the heavy
lift. Here's an example from eng.git:</p>

<pre><code>DOC_FILES        = index.md boilerplateapi.md
JS_FILES        := $(shell ls *.js) $(shell find lib test -name '*.js')
JSL_CONF_NODE    = tools/jsl.node.conf
JSL_FILES_NODE   = $(JS_FILES)
JSSTYLE_FILES    = $(JS_FILES)
JSSTYLE_FLAGS    = -o indent=4,doxygen,unparenthesized-return=0
SMF_MANIFESTS_IN = smf/manifests/bapi.xml.in

include ./Makefile.defs
include ./Makefile.node.defs
include ./Makefile.smf.defs

.PHONY: all
all: $(SMF_MANIFESTS) | $(NPM_EXEC)
    $(NPM) install

include ./Makefile.deps
include ./Makefile.node.targ
include ./Makefile.smf.targ
include ./Makefile.targ
</code></pre>

<p>All of the included Makefiles are modular and know nothing about this repo, but
this Makefile provides all of the required targets: "docs" to build HTML from
restdown, "check" to check SMF manifests as well as JavaScript style and lint,
"all" to build node and npm and then use that npm to rebuild local dependencies,
"clean" to remove built files, and so on.</p>

<p>See the top-level Makefile in eng.git for the complete details.</p>

<h1 id="software-development-process">Software development process</h1>

<p>Team synchronization begins daily with our morning scrum over XMPP. We use
continuous integration with Git. Bugs and feature requests are tracked in Jira.
For more details on Joyent's morning scrum please read: <a href="https://hub.joyent.com/wiki/display/dev/Engineering+Process">Engineering
Process</a>.</p>

<p>In general, process is shrink-to-fit: we adopt process that help us work better,
but process for process's sake is avoided. Any resemblance to formalized
methodologies, living or dead, is purely coincidental.</p>

<h1 id="security-statement-and-best-practices">Security Statement and Best Practices</h1>

<p>Joyent Engineering makes security a top priority for all of our projects. All engineering work is expected to follow industry best practices. New changes affecting security are reviewed by a developer other than the person who wrote the new code. Both developers test that these changes are not vulnerable to the OWASP top 10 security, pass PCI DSS, and are safe.</p>

<p>Common vulnerabilities to watch out for:</p>

<ul>
<li>Prevent code injection</li>
<li>Buffer overflow. Truncate strings at their maximum length.</li>
<li>Encrypt all sensitive data over HTTPS.</li>
<li>Do not leak sensitive data into error logs.</li>
<li>Block cross-site-scripting(XSS) by specifically validating input and auto-escaping HTML template output.</li>
<li>Wrap all routes in security checks to verify user passes ACLs.</li>
<li>Prevent cross-site-request-forgery(CSRF)</li>
</ul>

<h2 id="production-code-deployment-process">Production code deployment process</h2>

<p>For the Joyent Public Cloud, Jira change tickets should include the following before the code is promoted to production:</p>

<ul>
<li>Description of the change's impact</li>
<li>Record of approval by authorized stake holders</li>
<li>Confirmation of the code's functionality and proof that vulnerablity testing was performed. A log or screenshot from a security scanner is sufficient</li>
<li>Steps to undo this change if necessary.</li>
</ul>

<p>For reference, read the <a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project">owasp top 10</a> vulnerabilities.</p>

<h1 id="miscellaneous-best-practices">Miscellaneous Best Practices</h1>

<ul>
<li>Use JSON for config data. Not ini files: iniparser module has bugs, there
are always questions about encoding non-string values.</li>
<li>For services and distributed systems, consider building rich tools to
understand the state of the service, like lists of the service's objects and
information about each one. Think of the SmartOS proc(1) tools (see man pages
for pgrep, pstack, pfiles, pargs).</li>
<li>Consider doing development inside a SmartOS zone rather than on your Macbook
or a CoaL global zone. That forces us to use our product the way customers
might, and it eliminates classes of problems where the dev environment doesn't
match production (e.g., because you've inadvertently picked up a
globally-installed library instead of checking it in, or resource limits
differ between MacOS and a SmartOS zone.</li>
<li>Whether you develop in CoaL or on your Macbook, document what's necessary to
get from scratch to a working development environment so that other people can
try it out. Ideally, automate it. Having a script is especially useful if you
do develop on CoaL, which also forces you to keep it up to date.</li>
<li>Similarly, build tools to automate deploying bits to a test system (usually a
SmartOS headnode zone). The easier it is to test the actual deployment, the
more likely people will actually test that, and you'll catch environment
issues in development instead of after pushing.</li>
</ul>

<h1 id="examples">Examples</h1>

<ul>
<li>The <a href="boilerplateapi.html">boilerplate API</a> example in this repo gives you a
starter file and some suggestions on how to document a web service.</li>
</ul>

    </div> <!-- #content -->
<script type="text/javascript" charset="utf-8">
$(function() {
    var headerHeight = $("#header").height();

    var sections = $("#content h1[id], #content h2[id]");
    var sectionOffsets = [];
    var slack = 100;  // Give the section scroll some slack (in pixels).
    sections.each(function(elem) {
        sectionOffsets.push($(this).offset().top - headerHeight - slack);
    });

    var currSectionIdx = -1;
    function getSectionIdx(scrollDistance) {
        if (scrollDistance < sectionOffsets[0]) {
            return -1;
        } else {
            for (var id = sectionOffsets.length; id > 0; id--) {
                if (scrollDistance > sectionOffsets[id - 1]) {
                    return id - 1;
                    break;
                }
            }
        }
    }

    /** {{{ http://code.activestate.com/recipes/577787/ (r2) */
    _slugify_strip_re = /[^\w\s-]/g;
    _slugify_hyphenate_re = /[-\s]+/g;
    function slugify(s) {
      s = s.replace(_slugify_strip_re, '').trim().toLowerCase();
      s = s.replace(_slugify_hyphenate_re, '-');
      return s;
    }
    /** end of http://code.activestate.com/recipes/577787/ }}} */

    /* See <https://github.com/trentm/restdown/issues/11>. */
    function safechars(s) {
      return s.replace(_slugify_strip_re, '');
    }

    $("#content").scroll(function() {
        var scrollDistance = $("#content").scrollTop();
        var sectionIdx = getSectionIdx(scrollDistance);

        if (sectionIdx !== currSectionIdx) {
            $("#sidebar li>div").removeClass("current");
            currSectionIdx = sectionIdx;
            if (currSectionIdx >= 0) {
                var heading = $(sections[currSectionIdx]).text();
                var possibleAnchors = [
                    slugify(heading), // h1 or non-method h2
                    heading.replace(/ /g, '-'), // h2 method, just name or just endpoint
                    heading.slice(0, heading.lastIndexOf(' (')).trimRight().replace(/ /g, '-'), // h2 method, name and endpoint
                ];
                for (var i=0; i < possibleAnchors.length; i++) {
                    var anchor = safechars(possibleAnchors[i]);
                    try {
                        $("#sidebar a[href=#" + anchor + "]").parent().addClass("current");
                    } catch (e) {
                        /* Ignore error if no such element. */
                        console.log(e)
                    }
                }
            }
        }
    });
});
</script>

</body>
</html>
